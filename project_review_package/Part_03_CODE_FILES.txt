# CODE REVIEW - PART 3
Generated: 2026-02-02 15:17:36
Files in this part: 4

========================================


// ##########################################
// FILE: backend\analytics\revenueOptimizer.js
// SIZE: 3807 bytes
// MODIFIED: 2026-02-01 21:37:03
// ##########################################

const Room = require("../models/Room");
const Payment = require("../models/Payment");
const { predictChurn } = require("./churnModel");

/* =====================================================
   REVENUE OPTIMIZATION ENGINE
   - Explainable AI logic
   - Business-focused insights
   - ML-ready for future
===================================================== */

async function optimizeRevenue() {
    /* =======================
       OCCUPANCY ANALYSIS
    ======================= */
    const rooms = await Room.find({}, "totalBeds occupiedBeds");

    const totals = rooms.reduce(
        (acc, r) => {
            acc.totalBeds += r.totalBeds || 0;
            acc.occupiedBeds += r.occupiedBeds || 0;
            return acc;
        },
        { totalBeds: 0, occupiedBeds: 0 }
    );

    const occupancyRate =
        totals.totalBeds === 0
            ? 0
            : (totals.occupiedBeds / totals.totalBeds) * 100;

    /* =======================
       PAYMENT COLLECTION
    ======================= */
    const payments = await Payment.find();

    const totalBilled = payments.reduce(
        (s, p) => s + (p.amount || 0),
        0
    );

    const collected = payments
        .filter((p) => p.status === "paid")
        .reduce((s, p) => s + (p.amount || 0), 0);

    const collectionRate =
        totalBilled === 0 ? 0 : (collected / totalBilled) * 100;

    /* =======================
       CHURN IMPACT
    ======================= */
    const churnData = await predictChurn();
    const highRiskResidents = churnData.highRisk || 0;

    /* =======================
       INSIGHTS GENERATION
    ======================= */
    const insights = [];
    let revenueLeakEstimate = 0;

    // 🔻 Low occupancy
    if (occupancyRate < 70) {
        const emptyBeds = totals.totalBeds - totals.occupiedBeds;
        const avgRent = 600; // configurable later

        revenueLeakEstimate += emptyBeds * avgRent;

        insights.push({
            type: "OCCUPANCY",
            severity: "HIGH",
            message: "Low occupancy detected",
            recommendation:
                "Consider promotional pricing or short-term discounts to improve occupancy."
        });
    }

    // 💸 Poor collection
    if (collectionRate < 85) {
        revenueLeakEstimate += totalBilled - collected;

        insights.push({
            type: "PAYMENTS",
            severity: "MEDIUM",
            message: "Low payment collection rate",
            recommendation:
                "Enable automated reminders and enforce late fees to improve cash flow."
        });
    }

    // 🚨 Churn risk
    if (highRiskResidents > 0) {
        insights.push({
            type: "CHURN",
            severity: "HIGH",
            message: `${highRiskResidents} residents at high churn risk`,
            recommendation:
                "Offer retention incentives or proactive support to prevent revenue loss."
        });
    }

    // ✅ Healthy state
    if (insights.length === 0) {
        insights.push({
            type: "HEALTHY",
            severity: "LOW",
            message: "Revenue performance is healthy",
            recommendation:
                "Maintain current pricing and operational strategy."
        });
    }

    return {
        generatedAt: new Date(),
        metrics: {
            occupancyRate: Number(occupancyRate.toFixed(2)),
            collectionRate: Number(collectionRate.toFixed(2)),
            totalBeds: totals.totalBeds,
            occupiedBeds: totals.occupiedBeds
        },
        revenueLeakEstimate: Math.round(revenueLeakEstimate),
        insights
    };
}

module.exports = {
    optimizeRevenue
};





// ##########################################
// FILE: backend\config\db.js
// SIZE: 339 bytes
// MODIFIED: 2026-01-27 00:01:28
// ##########################################

const mongoose = require("mongoose");

const connectDB = async () => {
    try {
        await mongoose.connect(process.env.MONGO_URI);
        console.log("✅ MongoDB connected");
    } catch (err) {
        console.error("❌ MongoDB error:", err.message);
        process.exit(1);
    }
};

module.exports = connectDB;





// ##########################################
// FILE: backend\controllers\adminController.js
// SIZE: 1397 bytes
// MODIFIED: 2026-02-02 14:56:05
// ##########################################

const User = require("../models/User");
const bcrypt = require("bcryptjs");

/* GET ALL RESIDENTS */
exports.getAllResidents = async (req, res) => {
    try {
        const residents = await User.find({ role: "resident" })
            .select("-password")
            .sort({ createdAt: -1 });

        res.json(residents);
    } catch (err) {
        res.status(500).json({ message: "Failed to fetch residents" });
    }
};

/* ADD RESIDENT */
exports.addResident = async (req, res) => {
    try {
        const { name, email, password } = req.body;

        if (!name || !email || !password) {
            return res.status(400).json({ message: "All fields required" });
        }

        const exists = await User.findOne({ email });
        if (exists) {
            return res.status(400).json({ message: "Email already exists" });
        }

        const hashedPassword = await bcrypt.hash(password, 10);

        const resident = await User.create({
            name,
            email,
            password: hashedPassword,
            role: "resident"
        });

        res.status(201).json({
            _id: resident._id,
            name: resident.name,
            email: resident.email,
            role: resident.role
        });
    } catch (err) {
        res.status(500).json({ message: "Failed to add resident" });
    }
};





// ##########################################
// FILE: backend\index.js
// SIZE: 2810 bytes
// MODIFIED: 2026-02-01 20:48:36
// ##########################################

require("dotenv").config();

const express = require("express");
const cors = require("cors");
const mongoose = require("mongoose");

/* ================= APP INIT ================= */
const app = express(); // MUST be before routes
const PORT = process.env.PORT || 5000;

/* ================= CORS ================= */
const allowedOrigins = [
    "https://tagt.website",
    "https://www.tagt.website"
];

app.use(
    cors({
        origin: function (origin, callback) {
            if (!origin) return callback(null, true);

            if (allowedOrigins.includes(origin)) {
                return callback(null, true);
            }

            return callback(
                new Error("CORS not allowed for origin: " + origin),
                false
            );
        },
        credentials: true
    })
);

/* ================= MIDDLEWARE ================= */
app.use(express.json());

/* ================= DB CONNECT ================= */
if (!process.env.MONGO_URI) {
    console.error("❌ MONGO_URI not defined");
    process.exit(1);
}

mongoose
    .connect(process.env.MONGO_URI)
    .then(() => console.log("✅ MongoDB connected"))
    .catch((err) => {
        console.error("❌ MongoDB connection failed", err);
        process.exit(1);
    });

/* ================= ROUTES ================= */
const authRoutes = require("./routes/auth");
const adminRoutes = require("./routes/admin");
const roomRoutes = require("./routes/rooms");
const paymentRoutes = require("./routes/payments");
const residentRoutes = require("./routes/resident");
const analyticsRoutes = require("./routes/analytics"); // ✅ NEW

/* ================= HEALTH ================= */
app.get("/api/health", (req, res) => {
    res.json({
        status: "OK",
        uptime: process.uptime(),
        timestamp: new Date()
    });
});

/* ================= API ROUTES ================= */
app.use("/api/auth", authRoutes);
app.use("/api/admin", adminRoutes);
app.use("/api/rooms", roomRoutes);
app.use("/api/payments", paymentRoutes);
app.use("/api/resident", residentRoutes);
app.use("/api/analytics", analyticsRoutes); // ✅ NEW

/* ================= 404 HANDLER ================= */
app.use((req, res) => {
    res.status(404).json({
        success: false,
        message: "Route not found"
    });
});

/* ================= ERROR HANDLER ================= */
app.use((err, req, res, next) => {
    console.error("❌ ERROR:", err.message);
    res.status(err.status || 500).json({
        success: false,
        message: err.message || "Server error"
    });
});

/* ================= START SERVER ================= */
app.listen(PORT, () => {
    console.log(`✅ Backend running on port ${PORT}`);
});




